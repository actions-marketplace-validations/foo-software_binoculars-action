"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const getUpdatedReportContent_1 = __importDefault(require("./helpers/getUpdatedReportContent"));
const lighthouse_persist_1 = __importDefault(require("@foo-software/lighthouse-persist"));
const lighthouseConfig_1 = __importDefault(require("./config/lighthouseConfig"));
const lighthouseOptions_1 = __importDefault(require("./config/lighthouseOptions"));
const logger_1 = __importDefault(require("./helpers/logger"));
const postComment_1 = __importDefault(require("./helpers/postComment"));
const slackNotify_1 = __importDefault(require("./helpers/slackNotify"));
exports.default = async ({ author, awsAccessKeyId, awsBucket, awsRegion, awsSecretAccessKey, branch, commentAccessToken, commentUrl, enableComments, locale, minScore, outputDirectory, pr, sha, slackWebhookUrl, url, urls, }) => {
    var _a, _b;
    const queue = urls || [url];
    if (!Array.isArray(queue)) {
        throw Error('invalid URL input');
    }
    const results = [];
    for (const queuedUrl of queue) {
        logger_1.default.info(`running audit: ${queuedUrl}`);
        const { localReport, result, report } = await lighthouse_persist_1.default({
            awsAccessKeyId,
            awsBucket,
            awsRegion,
            awsSecretAccessKey,
            config: lighthouseConfig_1.default(locale),
            options: lighthouseOptions_1.default,
            outputDirectory,
            updateReport: getUpdatedReportContent_1.default,
            url: queuedUrl,
        });
        const score = (_b = (_a = result === null || result === void 0 ? void 0 : result.categories) === null || _a === void 0 ? void 0 : _a.binocularsSeo) === null || _b === void 0 ? void 0 : _b.score;
        const scoreText = typeof score !== 'number' ? '' : ` with a score of ${score * 100}`;
        logger_1.default.info(`✔️ audit complete${scoreText}`);
        if (localReport) {
            logger_1.default.info(`local report path: ${localReport}`);
        }
        if (report) {
            logger_1.default.info(`report path: ${report}`);
        }
        results.push({
            localReport,
            result,
            report,
            url: queuedUrl,
        });
    }
    if (commentAccessToken && commentUrl && enableComments) {
        await postComment_1.default({
            commentAccessToken: `${commentAccessToken}`,
            commentUrl: `${commentUrl}`,
            results,
        });
        logger_1.default.info('✔️ comment posted');
    }
    if (typeof slackWebhookUrl === 'string') {
        await slackNotify_1.default({
            author,
            branch,
            pr,
            results,
            sha,
            slackWebhookUrl,
        });
    }
    if (typeof minScore === 'number') {
        const failedAudits = [];
        for (const result of results) {
            const score = result.result.categories.binocularsSeo.score * 100;
            if (score < minScore) {
                failedAudits.push({
                    url: result.url,
                    score,
                });
            }
        }
        if (failedAudits.length) {
            throw Error(`Minimum score requirement of ${minScore} failed. ${JSON.stringify(failedAudits)}`);
        }
    }
    return results;
};
//# sourceMappingURL=binoculars.js.map